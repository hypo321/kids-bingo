<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="https://olioapp.com/en/wp-content/uploads/sites/1/2023/03/cropped-icon-512-1-32x32.png"
    sizes="32x32" />
  <link rel="icon" href="https://olioapp.com/en/wp-content/uploads/sites/1/2023/03/cropped-icon-512-1-192x192.png"
    sizes="192x192" />
  <link rel="apple-touch-icon"
    href="https://olioapp.com/en/wp-content/uploads/sites/1/2023/03/cropped-icon-512-1-180x180.png" />
  <meta name="msapplication-TileImage"
    content="https://olioapp.com/en/wp-content/uploads/sites/1/2023/03/cropped-icon-512-1-270x270.png" />
  <title>Spring Clean Bingo</title>
  <style>
    /* Reset default margins and ensure border-box sizing for consistent layout */
    * {
      box-sizing: border-box;

    }

    @font-face {
      font-family: 'Cosmica Bold';
      src: url('Cosmica-Bold.woff2') format('woff2');
      font-weight: normal;
      font-style: normal;
    }

    @font-face {
      font-family: 'Plus Jakarta Sans';
      src: url('PlusJakartaSans-VariableFont_wght.woff2') format('woff2');
      font-weight: 100 900;
      font-style: normal;
    }

    html,
    body {

      height: 100%;
      font-family: 'Plus Jakarta Sans', sans-serif;
      padding: 0;
      margin: 0;
    }

    h1,
    h2,
    .bold-text {
      font-family: 'Cosmica Bold', sans-serif;
    }
    html {
        background: url('spring-clean-background.png') center;
        background-size:auto;
    }

    body {



      /* constrain content width to 800px */

      /* prevent any scrolling */
    }



    body {
      --w: calc(2vw);
      --h: calc(2vh);
      font-size: clamp(0.6rem, min(var(--w), var(--h)), 2rem);
      /* You can adjust this value according to your preference */

    }



    /* Header styling */
    .title {
      grid-area: header;
      display: flex;

      justify-content: center;
      align-items: center;
      /* centre in the grid cell */
      width: 100%;
      height: 100%;
      border: red 1px solid;
      gap: 0.5rem;
      font-size: 4rem;
      /* center horizontally within body */
    }


       @media (orientation: portrait) {
      .title {
        font-size: 3rem;
        flex-direction: column;
        line-height: 3rem;

      }
    }



    .title span.purpleText {
      color: #261750;
    }
    .title span.pinkText {
      color: #ff4c70;
    }

    .title img {
      width: 100%;
      max-width: 400px;
    }

    /* Container for the bingo grid (the "board") */
    #boardContainer {
      grid-area: board;
      position: relative;
      /* 4x4 grid layout */
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 4px;
      /* 4px gap between cells (grid lines) */
      width: 80vmin;
      height: 80vmin;
      margin: 0 auto;

      --w: calc(calc(100vw / 5) + calc(4 * 4));
      --h: calc(calc(100vh / 5) + calc(4 * 4));
      width: min(var(--w), var(--h));
      height: min(var(--w), var(--h));




    }



    /* Each bingo cell styling */
    .cell {
      background: #dedbec;
      position: relative;
      /* text centred in the cell */
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;

      font-weight: bold;
      color: #fff;
      text-align: center;
      padding: 1%;
      /* max width and height
      max-width: 200px;
      max-height: 200px;
      min-width: 110px;
      min-height: 110px;*/
      --w: calc(100vw / 5.5);
      --h: calc(100vh / 5.5);
      width: min(var(--w), var(--h));
      height: min(var(--w), var(--h));



      /* The cell will auto size to fill one grid slot. No explicit width/height needed here
         because the grid defines them. Each cell is initially white. */
      /* pointer */
      cursor: pointer;
      user-select: none;
      border-radius: 15%;
    }







    .pink {
      background: #ff4c70;
      transition: background-color 0.5s ease-in-out;
      border: #ffb000 2px solid;
    }
    .orange {
      background: #ffb000;
      transition: background-color 0.5s ease-in-out;
      border: #ff4c70 2px solid;
    }
    /* Checked state for outer cells */
    .checked {
      background: #00bf63;
      /* green highlight when checked */
      transition: background-color 0.5s ease-in-out;
    }



    /* Olio logo at bottom-center */
    #logo {

      /* centre in the grid cell */


      width: clamp(100px, calc(5vw + 10vh), 200px);
      height: auto;
      pointer-events: none;
      margin: auto;
      bottom: 0px;

    }

    /* Footer styling */
    #footer {
      grid-area: footer;
      display: flex;
      justify-content: center;
      align-items: center;
      /* centre in the grid cell */
      width: 100%;
      height: 100%;
      margin: auto;

      /* center horizontally within body */
    }

    /* main column flex 1 column, 3 rows */
    .mainColumn {

      display: grid;
      grid-template-areas:
        "header"
        "board"
        "footer";
      grid-template-rows: 10% 1fr auto;

      gap: 1rem;
      justify-content: center;
      align-items: center;
      /* center the title and logo */
      width: 100%;
      height: 100vh;
      /* enough space for the title and logo top and  bottom, and maximise the middle row for the grid. */
    }

    @media (orientation: portrait) {
      .mainColumn {

        grid-template-rows: 20% auto auto;

        /* enough space for the title and logo top and  bottom, and maximise the middle row for the grid. */
      }
    }

    /* But in cases where screen is short but wide, I want the frist and third elements to be in a second column to the right of the grid */
    @media (max-height: 850px) and (min-width: 650px) {
      .mainColumn {
        grid-template-columns: 60% 1fr;
        width:auto;
        grid-template-rows: 60% 1fr;
        grid-template-areas:
          "board header"
          "board footer";
        gap: 4rem;
        /* enough space for the title and logo top and  bottom, and maximise the middle row for the grid. */
      }



    }

    /* Ensure the canvas covers the entire viewport as an overlay */
    #confettiCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      /* So it doesn't block clicks on your page */
      z-index: 9999;
      /* High z-index to appear on top */
    }

    /* Modal overlay styling */
    .modal {
      display: none;
      /* hidden by default */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      justify-content: center;
      align-items: center;
      z-index: 10000;
    }

    .modal-content {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      width: 80%;
      max-width: 700px;
      text-align: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      text-wrap: balanced;
    }

    .modal-content h2 {
      margin-top: 0;
    }

    .modal-content button {
      margin-top: 15px;
      padding: 10px 20px;
      font-size: 1rem;
      cursor: pointer;
      border: none;
      background: #ff4c70;
      color: #fff;
      border-radius: 4px;
    }

    /* Help icon (question mark) styling */
    #help-icon {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #ff4c70;
      color: #fff;
      font-size: 2rem;
      line-height: normal;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      z-index: 999;
    }

    /* For wide but short screens, rearrange layout */
    @media screen and (min-width: 800px) and (max-height: 600px) {

      body {
        font-size: 0.8rem;
      }


    }
  </style>
</head>

<body>
  <canvas id="confettiCanvas"></canvas>
  <!-- Decorative sun in the top-left -->

  <!-- Help icon (question mark) in the top right -->
  <div id="help-icon">?</div>

  <div class="mainColumn">
    <!-- Title banner at the top -->
      <div class="title">
        <img src="logo-bingo.png" alt="Spring Clean Bingo"  />
      </div>

    <!-- Bingo board container (3x3 grid) -->

    <!-- Chick image positioned behind the board -->

    <div id="boardContainer">

      <!-- 9 Bingo cells: 8 clickable outer cells and 1 center star cell -->

<div id="cell0" class="cell pink">Declutter your pantry or cupboards</div>
<div id="cell1" class="cell orange">List a pantry item on Olio</div>
<div id="cell2" class="cell pink">Answer a neighbour‚Äôs Wanted post on the app</div>
<div id="cell3" class="cell orange">Share spare kitchen items</div>
<div id="cell4" class="cell orange">List an item for sale on Olio</div>
<div id="cell5" class="cell pink">Have a fridge clearout</div>
<div id="cell6" class="cell orange">"Share a 'before and after' photo of your clear out"</div>
<div id="cell7" class="cell pink">List a piece of clothing on Olio</div>
<div id="cell8" class="cell pink">List a book on Olio</div>
<div id="cell9" class="cell orange">Declutter under your bed</div>
<div id="cell10" class="cell pink">Organise your wardrobe</div>
<div id="cell11" class="cell orange">Sort out your cleaning supplies</div>
<div id="cell12" class="cell orange">Tackle 'THAT' drawer</div>
<div id="cell13" class="cell pink">Unlock the 'Spring Cleaner' badge</div>
<div id="cell14" class="cell orange">List unused and unwanted toiletries</div>
<div id="cell15" class="cell pink">Organise your storage boxes</div>
    </div>


    <!-- Olio logo at the bottom -->
    <div id="footer">
      <img src="olio_purple.png" id="logo" alt="Olio Logo" />
    </div>
  </div>
  <!-- Modal for instructions -->
  <div id="modal" class="modal">
    <div class="modal-content">
      <h2>üåü Instructions üåü</h2>
      <p>This Bingo card is a fun and interactive way for you to help out at home during spring cleaning time. Each
        square
        has a simple task you can do to lend a hand and make spring cleaning a family effort.</p>
      <p><strong>‚úÖ How to play:</strong></p>
      <ul style="list-style: none; padding: 0;">
        <li>‚Ä¢ Tap or click a square when you‚Äôve finished the task to tick it off</li>
        <li>‚Ä¢ Try to complete as many as you can ‚Äì one tick at a time!</li>
        <li>‚Ä¢ Made a mistake? Press on the square again to undo it</li>
      </ul>
      <p>So roll up your sleeves, grab a grown-up if you need help, and let‚Äôs get spring cleaning! üí™üèºüßΩ</p>
      <p>Good luck and have fun! üåº</p>
      <button id="modal-ok">OK</button>
    </div>
  </div>
  <script>
    // Adjust on load and on window resize
    window.addEventListener('load', resizeBoard);
    window.addEventListener('resize', resizeBoard);

    // Function to trigger the Sponge animation at a given (x, y) position.
    function triggerSpongeAnimation(x, y, onComplete) {
      // Create a container div for the animation
      const sponge = document.createElement('div');
      sponge.style.position = 'absolute';
      sponge.style.left = `${x}px`;
      sponge.style.top = `${y}px`;
      sponge.style.zIndex = '10';
      // Ensure the element is positioned relative to its top-left corner
      sponge.style.transform = 'translate(-50%, -50%)';

      // Create the image element
      const img = document.createElement('img');
      img.src = 'Sponge.png';
      img.alt = 'Sponge';

      const spongeWidth=Math.min(window.innerWidth, window.innerHeight) * 0.2;
      img.style.width = spongeWidth + 'px';
      img.style.maxWidth = 'none';
      img.style.maxHeight = 'none';
      // Adjust the internal image offset if needed
      img.style.transform = 'translate(-30%, -50%)';
      sponge.appendChild(img);
      document.body.appendChild(sponge); // Append to body or another container as needed

      // Build the keyframe arrays (similar to your React component)
      const circlePoints = 8;
      let xPoints = [150, 0];
      let yPoints = [150, 0];
      let opacityPoints = [0, 1];
      let rotationPoints = [-30, -20];

      // Create the 3 circles of motion
      for (let circle = 0; circle < 2; circle++) {
        for (let i = 0; i < circlePoints; i++) {
          const angle = (i / circlePoints) * 2 * Math.PI;
          const radius = 30;
          xPoints.push(Math.cos(angle) * radius);
          yPoints.push(Math.sin(angle) * radius);
          opacityPoints.push(1);
          rotationPoints.push(i % 2 === 0 ? -25 : -15);
        }
      }

      // Add the return points
      xPoints.push(0, 150);
      yPoints.push(0, 150);
      opacityPoints.push(1, 0);
      rotationPoints.push(-20, -30);

      // Generate the timing values for each keyframe (a value between 0 and 1)
      const times = [];
      times.push(0, 0.15);
      const circleMotionDuration = 0.8;
      const circleStartTime = 0.15;
      const circleSegments = circlePoints * 2;
      for (let i = 0; i < circleSegments; i++) {
        times.push(circleStartTime + (i / circleSegments) * circleMotionDuration);
      }
      times.push(0.95, 1.0);

      // Construct keyframes array from the above arrays.
      const keyframes = [];
      for (let i = 0; i < xPoints.length; i++) {
        keyframes.push({
          offset: times[i],
          transform: `translate(${xPoints[i]}px, ${yPoints[i]}px) rotate(${rotationPoints[i]}deg)`,
          opacity: opacityPoints[i]
        });
      }

      // Start the animation: duration is 3000ms with a linear easing.
      const animation = sponge.animate(keyframes, {
        duration: 2000,
        easing: 'linear'
      });

      // Once the animation is finished, remove the element and call the callback.
      animation.onfinish = () => {
        console.log('Sponge animation complete');
        sponge.remove();
        if (onComplete) onComplete();
      };
    }




    // Get the canvas and context
    const canvas = document.getElementById('confettiCanvas');
    const ctx = canvas.getContext('2d');

    // Resize the canvas to cover the full viewport
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Confetti properties
    const confettiCount = 150;
    let confetti = [];
    const colours = ['#FFC107', '#E91E63', '#9C27B0', '#03A9F4', '#4CAF50'];

    // Initialise confetti particles
    function initConfetti() {
      confetti = []; // Reset the array
      for (let i = 0; i < confettiCount; i++) {
        confetti.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height - canvas.height,
          r: Math.random() * 6 + 2, // Size of the confetti
          d: Math.random() * confettiCount, // Density for movement variance
          colour: colours[Math.floor(Math.random() * colours.length)],
          tilt: Math.floor(Math.random() * 10) - 10,
          tiltAngleIncremental: (Math.random() * 0.07) + 0.05,
          tiltAngle: 0
        });
      }
    }

    // Draw confetti on the canvas
    function drawConfetti() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < confettiCount; i++) {
        const p = confetti[i];
        ctx.beginPath();
        ctx.lineWidth = p.r;
        ctx.strokeStyle = p.colour;
        ctx.moveTo(p.x + p.tilt + (p.r / 2), p.y);
        ctx.lineTo(p.x + p.tilt, p.y + p.tilt + (p.r / 2));
        ctx.stroke();
      }
      updateConfetti();
    }

    // Update confetti positions for the animation
    let angle = 0;
    function updateConfetti() {
      angle += 0.01;
      for (let i = 0; i < confettiCount; i++) {
        const p = confetti[i];
        p.tiltAngle += p.tiltAngleIncremental;
        p.y += (Math.cos(angle + p.d) + 3 + p.r / 2) / 2;
        p.x += Math.sin(angle);
        p.tilt = Math.sin(p.tiltAngle) * 15;

        // If the confetti goes off-screen, reset its position
        if (p.y > canvas.height) {
          p.y = -10;
          p.x = Math.random() * canvas.width;
        }
      }
    }

    // Variable to hold the animation frame id
    let animationFrameId = null;

    // Animation loop function
    function animateConfetti() {
      drawConfetti();
      animationFrameId = requestAnimationFrame(animateConfetti);
    }

    // Function to start the confetti animation
    function startConfetti() {
      if (!animationFrameId) { // Only start if it's not already running
        initConfetti();
        animateConfetti();
      }
    }

    // Function to stop the confetti animation
    function stopConfetti() {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        // Optionally clear the canvas once stopped:
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    }

    initConfetti(); // Initialise confetti on load



    // JavaScript for interactive functionality and responsiveness

    // Retrieve saved state from localStorage (if any)
    let savedState = localStorage.getItem('springBingoState');
    let cellChecked = savedState ? JSON.parse(savedState) : Array(16).fill(false);
    // cellChecked is an array of 9 booleans representing each cell (index 4 is center, always false in this context)

    // Get references to the DOM elements for cells and center star
    const cells = Array.from({ length: 16 }, (_, i) => document.getElementById('cell' + i));
    const centerCell = document.getElementById('cell4');

    // Function to update the center star based on outer cells
    function updateCenterCompletion() {
      const allChecked = cellChecked.every((checked, index) => checked);
      if (allChecked) {
        centerCell.classList.add('complete');
        startConfetti();
      } else {
        centerCell.classList.remove('complete');
        stopConfetti();
      }
    }

    // Add event listeners to outer cells for click toggling
    cells.forEach((cell, index) => {

      cell.addEventListener('click', () => {
        // Toggle state
        const currentlyChecked = cellChecked[index];
        cellChecked[index] = !currentlyChecked;
        // Update the cell's class for visual state
        if (cellChecked[index]) {
          cell.classList.add('checked');
                  // Get the centre coordinates of the cell.
          const rect = cell.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;

          // Trigger the sponge animation at the cell's centre.
          triggerSpongeAnimation(centerX, centerY, () => {
            // Optional: add any code to execute when the animation completes.
          });
        } else {
          cell.classList.remove('checked');
        }
        // Save updated state to localStorage
        localStorage.setItem('springBingoState', JSON.stringify(cellChecked));
        // Check if all outer cells are checked and update center accordingly
        updateCenterCompletion();
      });
    });

    // On page load, apply any saved checked classes and update center
    cells.forEach((cell, index) => {
      if ( cellChecked[index]) {
        cell.classList.add('checked');
      }
    });
    updateCenterCompletion();  // set center state based on initial data

    // Responsive resize: adjust board size to fit in viewport without overflow
    function resizeBoard() {

    }

    /* Modal functionality */
    const modal = document.getElementById('modal');
    const modalOk = document.getElementById('modal-ok');
    const helpIcon = document.getElementById('help-icon');


    // Show the modal if not already shown in a previous visit
    if (!localStorage.getItem('instructionsShown')) {
      modal.style.display = 'flex';
    }

    // Hide modal function
    function hideModal() {
      modal.style.display = 'none';
      localStorage.setItem('instructionsShown', 'true');
    }

    modalOk.addEventListener('click', hideModal);

    // Hide modal if clicking outside the modal content
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        hideModal();
      }
    });

    // Reopen modal when clicking the help icon
    helpIcon.addEventListener('click', () => {
      modal.style.display = 'flex';
    });

  </script>


</body>

</html>